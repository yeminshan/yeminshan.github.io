---
title: 防抖和节流
date: 2020-07-07 09:24:26
tags: ["防抖", "节流"]
categories: ["性能优化"]
---

防抖和节流这两个针对的都是函数，都是为了限制函数的执行次数，只是应用场景不一样，实现方式也不同。而这里的函数，通常是事件的响应函数。

# 什么是防抖(debounce)

防抖，是将一段时间内的函数调用视为同一"信号"，多次调用只是发生了"抖动"，应该被无视，停止调用后函数被真正的执行一次。 一般会给一个阀值表示"抖动"结束，如 1s 内函数不被触发。
去抖动，策略是当事件被触发时，设定一个周期延迟执行动作，**<u>若期间又被触发，则重新设定周期</u>**，直到周期结束，执行动作。

![策略示意图](https://img-blog.csdn.net/20180705005109564?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1cGlhbjE5ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/7)

前缘 debounce，即执行动作在前，然后设定周期，周期内有事件被触发，不执行动作，且周期重新设定。

![前缘debounce](https://img-blog.csdn.net/20180705005639201?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1cGlhbjE5ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**区别：执行事件的时机**

# 什么是节流(throttling)

节流，是限制函数过于频繁地执行，根据时间、次数等降低函数执行的频次。节流并不是断流，函数还是会多次执行，只是执行次数要降低。

节流的策略是：固定周期内，只执行一次动作，若有新事件触发，不执行。周期结束后，又有事件触发，开始新的周期。 节流策略也分前缘和延迟两种。与 debounce 类似，延迟是指 周期结束后执行动作，前缘是指执行动作后再开始周期。

![节流示意图](https://img-blog.csdn.net/20180705012049136?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1cGlhbjE5ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![前缘throttling](https://img-blog.csdn.net/20180705005639201?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1cGlhbjE5ODk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```js
// 简单示例
function debounce(fn, wait) {
  var timeout = null; //定义一个定时器
  return function () {
    if (timeout !== null)
      // ！
      clearTimeout(timeout); //清除这个定时器
    timeout = setTimeout(fn, wait);
  };
}
// 处理函数
function handle() {
  console.log(Math.random());
}
// 滚动事件
window.addEventListener("scroll", debounce(handle, 1000));
```

# 对比

![防抖和节流对比图](https://pics0.baidu.com/feed/ac345982b2b7d0a2d84acabf8034200f4a369a77.png?token=144594ffdcf72be54883f4d7b7d4ab43&s=8EAC5D22818C4CE8465540C40300D0B2)

在事件持续触发的情况下， 防抖是在某段时间内只执行一下， 而节流是根据一定的时间间隔执行。









参考：

[csdn](https://blog.csdn.net/hupian1989/article/details/80920324)


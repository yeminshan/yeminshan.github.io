---
title: 跨域
date: 2020-04-15 11:41:50
tags:
categories:
---

# 前言
```
广义的跨域：
1. 资源跳转： A链接、重定向、表单提交
2. 资源嵌入： <link>、<script>、<img>、<frame>等带src的dom标签，还有样式中background:url()、@font-face()等文件外链
3. 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
```
1. 需要跨域的原因

跨域问题其实就是浏览器的同源策略所导致的。

「同源策略」是一个重要的安全策略，限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。

同源策略限制以下几种行为：

1.Cookie、LocalStorage 和 IndexDB 无法读取

2.DOM 和 Js对象无法获得

3.AJAX 请求不能发送

# 跨域方案


## 1. jsonp

为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以【通过动态创建script，仅能用get方法】，再请求一个带参网址实现跨域通信。

jsonp是请求之后后台包装好一段json，并且把数据放在一个callback函数，返回一个js文件，动态引入这个文件，下载完成js之后，会去调用这个callback,通过这样访问数据。

JSONP主要就是利用了script标签没有跨域限制的这个特性来完成的，以及使用方法回调的原理.（缺点：只能实现get方法）。

流程：

1.前端定义解析函数（例如 jsonpCallback=function(){....}）

2.通过 params 形式包装请求参数，并且声明执行函数(例如 cb=jsonpCallback)

3.后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。

```html
<!-- 基本用法 -->
<!-- 前端 -->
<script>
  window.jsonpCallback = function(res) {
    console.log(res);
  };
</script>
<script src="http://localhost:8080/api/a.js?a=123&cb=sonpCallback"></script>

```


## 2. document.domain + iframe跨域（用于主域相同，子域不同的跨域应用场景）
需要共享的页面【都】设置相同的 document.domain
我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。
例如：a.b.c.com 中某个文档的document.domain 可以设成a.b.c.com、b.c.com 、c.com中的任意一个



## 3. location.hash + iframe跨域
实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
```html
<!-- a.html：(http://www.demo1.com/a.html) -->
<iframe id="iframe" src="http://www.demo2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>
<!-- b.html：(http://www.demo2.com/b.html) -->
<iframe id="iframe" src="http://www.demo1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>
<!-- c.html：(http://www.demo1.com/c.html) -->
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```



## 4. cros

跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器「不同的域、协议或端口」请求一个资源时，资源会发起一个「跨域 HTTP 请求」。


详见[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

普通跨域请求：只服务端设置Access-Control-Allow-Origin: "XXX"即可，前端无须设置，若要带cookie请求：前后端都需要设置。

Access-Control-Allow-Credentials:true，发送http认证信息，withCredentials:true，设置带cookie

## 5. Node 正向代理
引入：http-proxy-middleware

vue-cli高版本直接设置：proxy， 低版本设置：proxyTable，请求的时候不需要加上域名

## 6. Nginx 反向代理
```
服务器设置：
server {
        listen 80;
        server_name local.test;
        location /api {
            proxy_pass http://localhost:8080;
        }
        location / {
            proxy_pass http://localhost:8000;
        }
}
```



## 7. Websocket
websocket 本质上是没有使用HTTP 的响应头的，所以没有跨域的限制
客户端和服务器之间存在持久的连接，浏览器与服务器全双工通信，双向数据传输不限制跨域。

## 8. window.postMessage
Window.postMessage(message, targetOrigin, [transfer]);
 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。

 window.addEventListener("message", receiveMessage, false);
监听处理message 传递的数据
receiveMessage（e） {console.log(e.data)}

用途
1.页面和其打开的新窗口的数据传递

2.多窗口之间消息传递

3.页面与嵌套的 iframe 消息传递




## 9. window.name+iframe来进行跨域
window的name属性特征：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB），即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面window.name都有读写的权限。

因此，在同一个窗口打开(同一个iframe)，可共享name的值，name 的值只能是字符串。
思路： iframe打开一个不同域的页面，并将要访问的数据放在window.name中,然后将iframe转为同域的页面。
```html
<script>
// cnblogs.com/a.html
function getData(){
  //iframe载入data.html页面会执行此函数
  var ifr = document.getElementById("iframe");
  ifr.onload = function(){
    //这个时候iframe和a.html已经处于同一源，可以互相访问
    var data = ifr.contentWindow.name;
    //获取iframe中的window.name，也就是data.html中给它设置的数据
    alert(data);
  }
  ifr.src = 'b.html';//这里的b.html为随便一个页面，只要与a.html同源就行，目的是让a.html能够访问到iframe中的东西，否则访问不到
}
</script>
<iframe id = "iframe" src = "cnblogs.com/data.html" style = "display:none" onload = "getData()"></iframe>
```

参考资料：

[https://segmentfault.com/a/1190000011145364](https://segmentfault.com/a/1190000011145364)
[https://segmentfault.com/a/1190000022398875#item-3-6](https://segmentfault.com/a/1190000022398875#item-3-6)
[http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)
[https://www.cnblogs.com/sdcs/p/8484905.html](https://www.cnblogs.com/sdcs/p/8484905.html)